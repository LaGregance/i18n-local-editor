import * as fs from 'node:fs';
import { format } from 'prettier';
import { deleteObjectValueAtPath, pushIgnoreDuplicates, removeSuffix, setObjectValueAtPath } from '@/shared/utils';
import path from 'node:path';
import { getPWD } from '@/shared/get-pwd';
import { getEditorConfig } from '@/shared/config';

export abstract class I18nManager {
  static resolveFilePath(locale: string, namespace: string) {
    return path.join(
      getPWD(),
      getEditorConfig().pathToFiles.replace('{{locale}}', locale).replace('{{ns}}', namespace)
    );
  }

  static loadFile(filePath: string) {
    // TODO: Manage non JSON files
    return JSON.parse(fs.readFileSync(filePath, { encoding: 'utf8' }));
  }

  static saveFile(filePath: string, content: any) {
    // TODO: Manage non JSON files
    fs.writeFileSync(filePath, JSON.stringify(content, null, 4), { encoding: 'utf8' });
  }

  static async buildKeyFile() {
    const config = getEditorConfig();

    const defaultKeys: string[] = [];
    const keys: string[] = [];

    for (const locale of config.locales) {
      for (const namespace of config.namespaces) {
        const filePath = this.resolveFilePath(locale, namespace);
        const translations = this.flattenTranslations(this.loadFile(filePath));

        for (let key of Object.keys(translations)) {
          // Manage pluralization
          key = removeSuffix(key, ['_zero', '_one', '_others']);

          if (namespace === config.defaultNamespace) {
            pushIgnoreDuplicates(defaultKeys, key);
          }

          const fullKey = namespace + ':' + key;
          pushIgnoreDuplicates(keys, fullKey);
        }
      }
    }

    const content = `// This file is auto-generated by the build script

      export type TrKeys =
        ${[...defaultKeys, ...keys]
          .map(
            (key) => `/**
        * http://localhost:25560?key=${encodeURI(key)}
        */
        | '${key}'`
          )
          .join('\n')};
      
      export const trKeys = (key: TrKeys) => key;`;

    await format(content, { parser: 'typescript' });
    fs.writeFileSync(path.join(getPWD(), config.keyFile), await format(content, { parser: 'typescript' }), {
      encoding: 'utf8',
    });
  }

  /**
   * Take a JS object of key/value pair that contain nested object and flatten it
   * @param translations
   * @param prefix
   * @param result
   */
  private static flattenTranslations(translations: any, prefix = '', result: any = {}) {
    for (const key of Object.keys(translations)) {
      if (typeof translations[key] === 'object') {
        this.flattenTranslations(translations[key], prefix + key + '.', result);
      } else {
        result[prefix + key] = translations[key];
      }
    }

    return result;
  }

  /**
   * Load translations in format { key: { [locale]: value } }
   *
   * @param locales
   * @param namespaces
   */
  static loadTranslations(locales: string[], namespaces: string[]) {
    const result: any = {};

    for (const locale of locales) {
      for (const namespace of namespaces) {
        const filePath = this.resolveFilePath(locale, namespace);
        const translations = this.flattenTranslations(this.loadFile(filePath));

        for (const key of Object.keys(translations)) {
          result[namespace + ':' + key] ??= {};
          result[namespace + ':' + key][locale] = translations[key];
        }
      }
    }

    return result;
  }

  static setValue(keyWithNamespace: string, value: any) {
    const confif = getEditorConfig();

    const splitted = keyWithNamespace.split(':');
    const namespace = splitted[0];
    const key = splitted[1];

    if (!namespace || !key) {
      throw new Error('Invalid key');
    } else if (!confif.namespaces.includes(namespace)) {
      throw new Error('Unknown namespace');
    }

    const locales = value ? Object.keys(value) : confif.locales;

    for (const locale of locales) {
      if (!confif.locales.includes(locale)) {
        throw new Error(`Unknown locale ${locale}`);
      }
      const filePath = this.resolveFilePath(locale, namespace);
      const content = this.loadFile(filePath);
      if (!value || !value[locale]) {
        deleteObjectValueAtPath(content, key);
      } else {
        setObjectValueAtPath(content, key, value[locale]);
      }
      this.saveFile(filePath, content);
    }
  }
}
